/*
 * generated by Xtext 2.32.0
 */
package diro.geodes.generator

import java.util.ArrayList
import library.commands.AddCommandGenerator
import library.commands.CheckoutCommandGenerator
import library.commands.CheckoutCreateCommandGenerator
import library.commands.CloneCommandGenerator
import library.commands.CommandGenerator
import library.commands.CommitCommandGenerator
import library.commands.CreateBranchCommandGenerator
import library.commands.FetchCommandGenerator
import library.commands.ICommandGenerator
import library.commands.InitCommandGenerator
import library.commands.LogCommandGenerator
import library.commands.OpenCommandGenerator
import library.commands.PullCommandGenerator
import library.commands.PushCommandGenerator
import library.commands.RemoteAddCommandGenerator
import library.commands.RmCommandGenerator
import org.eclipse.core.resources.IFolder
import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.IProjectDescription
import org.eclipse.core.resources.IWorkspaceRoot
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.jdt.core.IClasspathEntry
import org.eclipse.jdt.core.IJavaProject
import org.eclipse.jdt.core.IPackageFragment
import org.eclipse.jdt.core.IPackageFragmentRoot
import org.eclipse.jdt.core.JavaCore
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.io.FileWriter
import java.io.FileOutputStream
import java.io.Writer
import java.io.BufferedWriter
import java.io.OutputStreamWriter
import library.handlers.HandlerGenerator
import library.handlers.AddHandlerGenerator
import library.handlers.CheckoutHandlerGenerator
import library.handlers.CheckoutCreateHandlerGenerator
import library.handlers.CloneHandlerGenerator
import library.handlers.CommitHandlerGenerator
import library.handlers.CreateBranchHandlerGenerator
import library.handlers.FetchHandlerGenerator
import library.handlers.InitHandlerGenerator
import library.handlers.LogHandlerGenerator
import library.handlers.OpenHandlerGenerator
import library.handlers.PullHandlerGenerator
import library.handlers.PushHandlerGenerator
import library.handlers.RemoteAddHandlerGenerator
import library.handlers.RmHandlerGenerator
import library.dialogs.DialogGenerator
import library.dialogs.AddDialogGenerator
import library.dialogs.RmDialogGenerator
import library.dialogs.CheckoutDialogGenerator
import library.dialogs.CheckoutCreateDialogGenerator
import library.dialogs.CloneDialogGenerator
import library.dialogs.CommitDialogGenerator
import library.dialogs.CreateBranchDialogGenerator
import library.dialogs.FetchDialogGenerator
import library.dialogs.InitDialogGenerator
import library.dialogs.LogDialogGenerator
import library.dialogs.OpenDialogGenerator
import library.dialogs.PullDialogGenerator
import library.dialogs.PushDialogGenerator
import library.dialogs.RemoteAddDialogGenerator
import library.controllers.IVcsControllerGenerator
import library.controllers.PorcelainControllerGenerator
import library.controllers.ControllerGenerator
import library.functions.FunctionGenerator
import library.functions.JGitRepositoryAPIGenerator
import library.dialogs.DialogUtilsGenerator
import library.dialogs.PathDialogGenerator
import vcsFeaturesMM.HighLevelCommand

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class VcsFeaturesGenerator extends AbstractGenerator {
//https://goto40.github.io/self-dsl/xtext_code_generation_xtend/
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// https://stackoverflow.com/questions/13772464/can-i-generate-eclipse-workspace-and-project-manually-programmatically
		// This piece is to generate a new project where we can generate all of our files into
		/*val IProgressMonitor progressMonitor = new NullProgressMonitor();
		val IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
		val IProject project = root.getProject("VCSFeatures"); // TODO I should collect the project's name from the wizard too.
		project.create(progressMonitor);
		project.open(progressMonitor);

		
		val IProjectDescription description = project.getDescription();
		val ArrayList<String> natures = new ArrayList<String>()
		natures.add("org.eclipse.jdt.core.javanature")
		//natures.add("org.eclipse.pde.core.org.eclipse.pde.PluginNature")
		// RCP plugin nature?
		//natures.add("org.eclipse.e4.ui.workbench.swt.E4Application")
		
		description.setNatureIds(natures)
		
		//create the project
		project.setDescription(description, null);
		val IJavaProject javaProject = JavaCore.create(project);
		
		//set the build path
		/*val IClasspathEntry[] buildPath = new ArrayList<IClasspathEntry>
		buildPath.add(JavaCore.newSourceEntry(project.fullPath.append("src")));
		
		javaProject.setRawClasspath(buildPath, project.getFullPath().append(
                "bin"), null);*/
		
		
		//create folder by using resources package
		/*val IFolder folder = project.getFolder("src");
		folder.create(true, true, null);
		
		//Add folder to Java element
		val IPackageFragmentRoot srcFolder = javaProject
		                .getPackageFragmentRoot(folder);
		
		//create package fragments
		val IPackageFragment commandsFragment = srcFolder.createPackageFragment(
		        "commands", true, null);
        val IPackageFragment controllersFragment = srcFolder.createPackageFragment(
		        "controllers", true, null);
        val IPackageFragment dialogsFragment = srcFolder.createPackageFragment(
		        "dialogs", true, null);
        val IPackageFragment functionsFragment = srcFolder.createPackageFragment(
		        "functions", true, null);
        val IPackageFragment handlersFragment = srcFolder.createPackageFragment(
		        "handlers", true, null);*/

		
		//val projectPath = project.fullPath.toString
		
		// List of commands to generate. Add as needed.
		val ArrayList<CommandGenerator> commands = new ArrayList<CommandGenerator>()
		commands.add(new AddCommandGenerator)
		commands.add(new CheckoutCommandGenerator)
		commands.add(new CheckoutCreateCommandGenerator)
		commands.add(new CloneCommandGenerator)
		commands.add(new CommitCommandGenerator)
		commands.add(new CreateBranchCommandGenerator)
		commands.add(new FetchCommandGenerator)
		commands.add(new ICommandGenerator)
		commands.add(new InitCommandGenerator)
		commands.add(new LogCommandGenerator)
		commands.add(new OpenCommandGenerator)
		commands.add(new PullCommandGenerator)
		commands.add(new PushCommandGenerator)
		commands.add(new RemoteAddCommandGenerator)
		commands.add(new RmCommandGenerator)

		
		for (cg : commands){
			// Have to split 2 times, to get only the name of the class, otherwise it writes the name of the class with the package name in front of it. 
			// We also want to remove the "Generator" at the end, because the class is the concrete version.
			fsa.generateFile('commands/' + cg.class.name.split("Generator").get(0).split("library.commands.").get(1) + '.java', cg.generate)
			// TODO The method doGenerate categorically refuses to write to the other project. I can create packages, but no files can be added.
			// It seems like a permission is not acquired and it can't write outside it's own project.
			// Error: java.io.FileNotFoundException: \VCSFeatures\commands\AddCommand.java (The system cannot find the path specified)
			// Try to find a fix for this, but maybe only manual copy-pasting will be an option
			/*try (
				val Writer writer = new BufferedWriter(new OutputStreamWriter(
          		new FileOutputStream(javaProject.path.makeAbsolute.toString + '/commands/' + cg.class.name.split("Generator").get(0).split("library.commands.").get(1) + '.java'), "utf-8"))) {
   				writer.write(cg.generate.toString);
			}*/
			//new FileOutputStream(srcFolder.path.makeAbsolute.toString + '/commands/' + cg.class.name.split("Generator").get(0).split("library.commands.").get(1) + '.java').write(cg.generate.toString).flush
			
		}
		
		// Generate all the super command and handlers classes
		for (superCommand : resource.allContents.filter(HighLevelCommand).toIterable){
			fsa.generateFile('commands/' + superCommand.name + 'Command.java', '''package commands;
			
			public class «superCommand.name + "Command"» extends SuperCommand {
			
			}
			''')
			
			fsa.generateFile('handlers/' + superCommand.name + 'Handler.java', '''
			package handlers;
			
			import org.eclipse.core.commands.AbstractHandler;
			import org.eclipse.core.commands.ExecutionEvent;
			import org.eclipse.core.commands.ExecutionException;
			import org.eclipse.jface.window.Window;
			import org.eclipse.ui.IWorkbenchWindow;
			import org.eclipse.ui.handlers.HandlerUtil;
			import org.eclipse.jface.dialogs.TitleAreaDialog;
			import commands.ICommand;
			«FOR lowCommands : superCommand.lowlevelcommand»import handlers.«lowCommands.command.getName.split("Command").get(0) + "Handler"»
			«ENDFOR»
			
			public class «superCommand.name + "Handler"» extends AbstractHandler {
				@Override
				public Object execute(ExecutionEvent event) throws ExecutionException {
					// get workbench window
					IWorkbenchWindow window = HandlerUtil.getActiveWorkbenchWindowChecked(event);
					«FOR lowCommands : superCommand.lowlevelcommand»
					new «lowCommands.command.getName.split("Command").get(0) + "Handler"»().execute(event);
					«ENDFOR»
					return null;
				}
			}''')
			
			
		}
		
		val ArrayList<HandlerGenerator> handlers = new ArrayList<HandlerGenerator>()
		handlers.add(new AddHandlerGenerator)
		handlers.add(new CheckoutHandlerGenerator)
		handlers.add(new CheckoutCreateHandlerGenerator)
		handlers.add(new CloneHandlerGenerator)
		handlers.add(new CommitHandlerGenerator)
		handlers.add(new CreateBranchHandlerGenerator)
		handlers.add(new FetchHandlerGenerator)
		handlers.add(new InitHandlerGenerator)
		handlers.add(new LogHandlerGenerator)
		handlers.add(new OpenHandlerGenerator)
		handlers.add(new PullHandlerGenerator)
		handlers.add(new PushHandlerGenerator)
		handlers.add(new RemoteAddHandlerGenerator)
		handlers.add(new RmHandlerGenerator)
		
		for (hg : handlers){
		fsa.generateFile('handlers/' + hg.class.name.split("Generator").get(0).split("library.handlers.").get(1) + '.java', hg.generate)
		}
		
		val ArrayList<DialogGenerator> dialogs = new ArrayList<DialogGenerator>()
		dialogs.add(new AddDialogGenerator)
		dialogs.add(new CheckoutDialogGenerator)
		dialogs.add(new CheckoutCreateDialogGenerator)
		dialogs.add(new CloneDialogGenerator)
		dialogs.add(new CommitDialogGenerator)
		dialogs.add(new CreateBranchDialogGenerator)
		dialogs.add(new DialogUtilsGenerator)
		dialogs.add(new FetchDialogGenerator)
		dialogs.add(new InitDialogGenerator)
		dialogs.add(new LogDialogGenerator)
		dialogs.add(new OpenDialogGenerator)
		dialogs.add(new PathDialogGenerator)
		dialogs.add(new PullDialogGenerator)
		dialogs.add(new PushDialogGenerator)
		dialogs.add(new RemoteAddDialogGenerator)
		dialogs.add(new RmDialogGenerator)
		
		for (dg : dialogs){
		fsa.generateFile('dialogs/' + dg.class.name.split("Generator").get(0).split("library.dialogs.").get(1) + '.java', dg.generate)
		}
		
		val ArrayList<ControllerGenerator> controllers = new ArrayList<ControllerGenerator>()
		controllers.add(new IVcsControllerGenerator)
		controllers.add(new PorcelainControllerGenerator)
		
		for (cg : controllers){
		fsa.generateFile('controllers/' + cg.class.name.split("Generator").get(0).split("library.controllers.").get(1) + '.java', cg.generate)
		}
		
		val ArrayList<FunctionGenerator> functions = new ArrayList<FunctionGenerator>()
		functions.add(new JGitRepositoryAPIGenerator)
		
		for (fg : functions){
		fsa.generateFile('functions/' + fg.class.name.split("Generator").get(0).split("library.functions.").get(1) + '.java', fg.generate)
		}
	}
}
