/*
 * generated by Xtext 2.32.0
 */
package diro.geodes.generator

import java.util.ArrayList
import library.commands.AddCommandGenerator
import library.commands.CheckoutCommandGenerator
import library.commands.CheckoutCreateCommandGenerator
import library.commands.CloneCommandGenerator
import library.commands.CommandGenerator
import library.commands.CommitCommandGenerator
import library.commands.CreateBranchCommandGenerator
import library.commands.FetchCommandGenerator
import library.commands.ICommandGenerator
import library.commands.InitCommandGenerator
import library.commands.LogCommandGenerator
import library.commands.OpenCommandGenerator
import library.commands.PullCommandGenerator
import library.commands.PushCommandGenerator
import library.commands.RemoteAddCommandGenerator
import library.commands.RmCommandGenerator
import org.eclipse.core.resources.IFolder
import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.IProjectDescription
import org.eclipse.core.resources.IWorkspaceRoot
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.jdt.core.IClasspathEntry
import org.eclipse.jdt.core.IJavaProject
import org.eclipse.jdt.core.IPackageFragment
import org.eclipse.jdt.core.IPackageFragmentRoot
import org.eclipse.jdt.core.JavaCore
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.io.FileWriter
import java.io.FileOutputStream
import java.io.Writer
import java.io.BufferedWriter
import java.io.OutputStreamWriter

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class VcsFeaturesGenerator extends AbstractGenerator {
//https://goto40.github.io/self-dsl/xtext_code_generation_xtend/
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// https://stackoverflow.com/questions/13772464/can-i-generate-eclipse-workspace-and-project-manually-programmatically
		// This piece is to generate a new project where we can generate all of our files into
		val IProgressMonitor progressMonitor = new NullProgressMonitor();
		val IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
		val IProject project = root.getProject("VCSFeatures"); // TODO I should collect the project's name from the wizard too.
		project.create(progressMonitor);
		project.open(progressMonitor);

		
		val IProjectDescription description = project.getDescription();
		val ArrayList<String> natures = new ArrayList<String>()
		natures.add("org.eclipse.jdt.core.javanature")
		//natures.add("org.eclipse.pde.core.org.eclipse.pde.PluginNature")
		// TODO RCP nature?
		
		description.setNatureIds(natures)
		
		//create the project
		project.setDescription(description, null);
		val IJavaProject javaProject = JavaCore.create(project);
		
		//set the build path
		/*val IClasspathEntry[] buildPath = new ArrayList<IClasspathEntry>
		buildPath.add(JavaCore.newSourceEntry(project.fullPath.append("src")));
		
		javaProject.setRawClasspath(buildPath, project.getFullPath().append(
                "bin"), null);*/
		
		
		//create folder by using resources package
		val IFolder folder = project.getFolder("src");
		folder.create(true, true, null);
		
		//Add folder to Java element
		val IPackageFragmentRoot srcFolder = javaProject
		                .getPackageFragmentRoot(folder);
		
		//create package fragments
		val IPackageFragment commandsFragment = srcFolder.createPackageFragment(
		        "commands", true, null);
        val IPackageFragment controllersFragment = srcFolder.createPackageFragment(
		        "controllers", true, null);
        val IPackageFragment dialogsFragment = srcFolder.createPackageFragment(
		        "dialogs", true, null);
        val IPackageFragment functionsFragment = srcFolder.createPackageFragment(
		        "functions", true, null);
        val IPackageFragment handlersFragment = srcFolder.createPackageFragment(
		        "handlers", true, null);

		
		//val projectPath = project.fullPath.toString
		
		// List of commands to generate. Add as needed.
		val ArrayList<CommandGenerator> commands = new ArrayList<CommandGenerator>()
		commands.add(new AddCommandGenerator)
		commands.add(new CheckoutCommandGenerator)
		commands.add(new CheckoutCreateCommandGenerator)
		commands.add(new CloneCommandGenerator)
		commands.add(new CommitCommandGenerator)
		commands.add(new CreateBranchCommandGenerator)
		commands.add(new FetchCommandGenerator)
		commands.add(new ICommandGenerator)
		commands.add(new InitCommandGenerator)
		commands.add(new LogCommandGenerator)
		commands.add(new OpenCommandGenerator)
		commands.add(new PullCommandGenerator)
		commands.add(new PushCommandGenerator)
		commands.add(new RemoteAddCommandGenerator)
		commands.add(new RmCommandGenerator)

		
		for (cg : commands){
			// Have to split 2 times, to get only the name of the class, otherwise it writes the name of the class with the package name in front of it. 
			// We also want to remove the "Generator" at the end, because the class is the concrete version.
			fsa.generateFile('commands/' + cg.class.name.split("Generator").get(0).split("library.commands.").get(1) + '.java', cg.generate)
			// TODO The method doGenerate categorically refuses to write to the other project. I can create packages, but no files can be added.
			// Error: java.io.FileNotFoundException: \VCSFeatures\commands\AddCommand.java (The system cannot find the path specified)
			// Try to find a fix for this, but maybe only manual copy-pasting will be an option
			/*try (
				val Writer writer = new BufferedWriter(new OutputStreamWriter(
          		new FileOutputStream(javaProject.path.makeAbsolute.toString + '/commands/' + cg.class.name.split("Generator").get(0).split("library.commands.").get(1) + '.java'), "utf-8"))) {
   				writer.write(cg.generate.toString);
			}*/
			//new FileOutputStream(srcFolder.path.makeAbsolute.toString + '/commands/' + cg.class.name.split("Generator").get(0).split("library.commands.").get(1) + '.java').write(cg.generate.toString).flush
			
		}
		
		
	}
}
