/*
 * generated by Xtext 2.32.0
 */
package diro.geodes.generator

import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.IWorkspaceRoot
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import library.commands.AddCommandGenerator
import library.commands.CommandGenerator
import java.util.ArrayList
import java.lang.reflect.Array
import library.commands.CheckoutCommandGenerator
import library.commands.CheckoutCreateCommandGenerator
import library.commands.CloneCommandGenerator
import library.commands.CommitCommandGenerator
import library.commands.CreateBranchCommandGenerator
import library.commands.FetchCommandGenerator
import library.commands.ICommandGenerator
import library.commands.InitCommandGenerator
import library.commands.LogCommandGenerator
import library.commands.OpenCommandGenerator
import library.commands.PullCommandGenerator
import library.commands.PushCommandGenerator
import library.commands.RemoteAddCommandGenerator
import library.commands.RmCommandGenerator
import org.eclipse.core.resources.IProjectDescription

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class VcsFeaturesGenerator extends AbstractGenerator {
//https://goto40.github.io/self-dsl/xtext_code_generation_xtend/
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// This piece is to generate a new project where we can generate all of our files into
		val IProgressMonitor progressMonitor = new NullProgressMonitor();
		val IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
		val IProject project = root.getProject("VCSFeatures"); // TODO I should collect the project's name from the wizard too.
		project.create(progressMonitor);
		project.open(progressMonitor);
		
		val IProjectDescription description = project.getDescription();
		val ArrayList<String> natures = new ArrayList<String>()
		natures.add("org.eclipse.jdt.core.javanature")
		description.setNatureIds(natures)
		project.setDescription(description, null);
		
		val projectPath = project.fullPath.toString
		
		// List of commands to generate. Add as needed.
		val ArrayList<CommandGenerator> commands = new ArrayList<CommandGenerator>()
		commands.add(new AddCommandGenerator)
		commands.add(new CheckoutCommandGenerator)
		commands.add(new CheckoutCreateCommandGenerator)
		commands.add(new CloneCommandGenerator)
		commands.add(new CommitCommandGenerator)
		commands.add(new CreateBranchCommandGenerator)
		commands.add(new FetchCommandGenerator)
		commands.add(new ICommandGenerator)
		commands.add(new InitCommandGenerator)
		commands.add(new LogCommandGenerator)
		commands.add(new OpenCommandGenerator)
		commands.add(new PullCommandGenerator)
		commands.add(new PushCommandGenerator)
		commands.add(new RemoteAddCommandGenerator)
		commands.add(new RmCommandGenerator)

		for (cg : commands){
			// Have to split 2 times, to get only the name of the class, otherwise it writes the name of the class with the package name in front of it. 
			// We also want to remove the "Generator" at the end, because the class is the concrete version.
			fsa.generateFile(projectPath + '/src/commands/' + cg.class.name.split("Generator").get(0).split("library.commands.").get(1) + '.java', cg.generate)
		}
		
		
	}
}
